\chapter{Zoeken in strings}
Dit hoofdstuk geeft uitleg over verschillende methodes om strings op te zoeken in een tekst.
Hierbij veronderstellen we dat we alle locatie willen vinden waar de string voorkomt. Merk op dat een string met zichzelf kan overlappen.
\npar
Daarvoor maken we gebruik van volgende terminologie:
\begin{itemize}
\item het patroon P dat we zoeken lengte = m 
\item tekst T met lengte = n
\item alfabet $\sum$ met d karaters 
\end{itemize}

\section{Variabele tekst}
\subsection{Eenvoudige methode}
\mijnfiguur[ht]{width=0.9\textwidth}{stringeen}{}
Deze methode is de eenvoudigste en zoekt gewoon of P vanaf een positie j voorkomt in T door de overeenkomstige karakters (op positie i) te vergelijken (P[i] == T[j+i-1] $\rightarrow$ i++; ). Indien er een verschillend karakter gevonden wordt zullen we de start positie eentje opschuiven (j++;) en opnieuw de karakters van P vergelijken.
\npar
Als de strings regelijk random zijn en we een groot alfabet hebben zal de eerste letter vaak verschillen waardoor we meestal na 1 vergelijking al kunnen opschuiven. Het gemiddeld geval is dan ook O(n).
\npar het slechtste geval is O(nm)dit doet zich voor als de eerste O(m) karakters van P op O(n) posities overeenkomen.(bv aaaab zoeken in aaaa....aaaaab) Dit lijkt zeer onwaarschijnlijk, maar als we de technieke gebruiken voor binaire strings of DNA strings met een klein alfabet is dit wel problematisch.

\subsection{Gebruik van de Prefixfunctie}
\subsubsection{Prefixfunctie}
\begin{table}[h]
\begin{tabular}{lrrrrrrrrr}
\textbf{index} &1 &2 &3 &4 &5 &6 &7 &8 &9 \\
\textbf{str} &a &a &b &a &a &b &a &b &b \\
                  \\
\textbf{p()} &0 &1 &0 &1 &2 &3 &4 &0 &0
\end{tabular}
\end{table}
De prefix functie p() van een string P bepaalt voor elke stringpositie i de lengte van het langste prefix van P, die overeenkomst met een deelstring van P, eindigend bij de positie i (1 <= i <= m). p(i) is dus steeds kleiner dan i en p(1) = nul.

\begin{lstlisting}
vector<int> PrefixFunction(string S) {
    vector<int> p(S.size());
    int j = 0;
    for (int i = 1; i < (int)S.size(); i++) {
        while (j > 0 && S[j] != S[i])
            j = p[j-1];

        if (S[j] == S[i])
            j++;
        p[i] = j;
    }   
    return p;
}
\end{lstlisting}
\clearpage
\subsubsection{Een eenvoudige lineaire methode}
\mijnfiguur[ht]{width=0.85\textwidth}{prefix}{}
Zoals je kan zien op \ref{prefix} zien we dat we het gevonden stuk string kunnen hergebruiken. We hebben namelijk ABABA al gevonden, echter de C klopt niet. Door nu echter de AB door te schuiven vermijden we extra vergelijkingen die toch negatief zouden zijn.
\npar
We berekenen m prefix waarden wat $\theta(m)$ tijd inneemt (gemiddeld). Dit betekent dat de buitenste herhaling gemiddeld (geatmortiseerd) O(1) is. Om dat aan te tonen moeten we gebruik maken van een potentiaal functie, de potentiaal komt overeen met de prefixfunctie zelf. 
Deze vormt zeker een bovengrens voor de uitvoeringstijd, want ze is initieel nul, en wordt nooit negatief. In de buitenste herhaling wordt ze minstens een kleiner (want we schuiven een op (zie 2 in de figuur)).
\npar
De afname van de potentiaal in de binnenste herhaling is dus minstens zo groot als het werk in die herhaling. De geatmortiseerde tijd van een buitenste herhaling is haar echte tijd plus de toename in potentiaal en dus 0(1). Aangezien er m-1 buitenste herhalingen zijn, is de totale performantie inderdaad $\theta(n)$.
\clearpage
\subsubsection{Knurth-Morris-Pratt}
\begin{itemize}
\item Zie link in de README $\rightarrow$ KMP in my own words (http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/)
\item gebruikt de prefix functie
\item beperkt het aantal binnenste iteraties 
\item P wordt met T vergeleken op een bepaalde positie:
\begin{itemize}
\item geen overeenkomst meer tussen P[i] en T[j]
\item foutpositie = 1: P 1tje naar rechts en T begint bij P[1]
\item foutpositie $>$ 01: 
\begin{itemize}
\item correcte prefix van P met lengte i-1 gevonden
\item eindigen bij positie j-1
\item P zo weinig mogelijk naar rechts verschuiven
\begin{itemize}
\item kortere prefix van P komt overeen met T tot positie j-1
\item kan begin zijn van volgende overeenkomst van P met T
\item langste van die kortere prefixen gebruiken
\item komt overeen met P: eindigend bij positie i-1 en lengte = p(i-1)
\item als P[ p(i-1) + 1 ] == T[j] : Vergelijke tussen P en T kan hier hervat worden, anders P opschuiven
\end{itemize}
\end{itemize}
\item P[i] en T[j] verschillen:
\begin{itemize}
\item er zal terug een fout optreden als P[ (i-1)+1 ] == P[i]
\item kortere, maar langst mogelijk prefix moet uitgeprobeerd worden waarbij karakter rechts ervan verschilt met P[i]
\item verschuiving vaak groter dan bij eenvoudige lineaire methode
\item karakter rechts verschilt van P[i], garandeert niet dat overeenkomt met T[j]; eventueel verder doorschuiven is nodig
\end{itemize}
\end{itemize}
\item bijkomende vereiste voor nieuwe prefix heeft enkel met P te maken
\begin{itemize}
\item nieuwe prefixwaarden p2(i) voor elke positie in P op voorhand bepalen.
\item met behulp van foutfunctie f(i) = p2(i-1) + 1
\item voor elke mogelijk fout positie i:
\begin{itemize}
\item i $>$ 1 : meteen patroon positie geven waarmee T[j] vergeleken moet worden
\item i == 1 : 
\begin{itemize}
\item P met 1 positie opschuiven
\item P[1] vergelijken met T[j+1]
\item f(1) moet 1 zijn, dus p2(0) = 0
\end{itemize}
\end{itemize}
\end{itemize}
\end{itemize}
{\Huge SAY WHATT??}
\npar We doen eignelijk niets magisch
\begin{enumerate}
\item bepaal de prefix functie
\begin{tabular}{lrrrrrrrr}
char: &a &b &a &b &a &b &c &a \\
index:&0 &1 &2 &3 &4 &5 &6 &7 \\
p():  &0 &0 &1 &2 &3 &4 &0 &1
\end{tabular}
\item We overlopen de string tot we een fout vinden op positie i (in P).
\item i == 1 ? $\rightarrow$ p eentje naar rechts
\item i $>$ 1  ? $\rightarrow$ een prefix vinden in P met lengte i-1 die eindigt op positie j-1 in T. Nu moeten we verschuiven volgende de prefix functie
\item als P[ p(i-1) +1 ] == T[j] : na verschuiving komen deze letters overeen en kunnen we dus vanaf hier verder doen
\item als dat niet overeenkomst moeten we P nog wat verder opschuiven tot P.firstChar terug gelijk is aan T[i]
\item tot hier passen we eigenlijk gewoon de lineaire methode toe

\item \textbf{als P(i) != T[j] hebben we direct terug een fout;} we hadden dus beter de 2e langste prefix genomen ipv de langste.
\begin{itemize}
\item we hebben dus een bijkomende vereiste voor de prefix functie, namelijk dat het karakter rechts van de prefix verschilt van P[i]. Hierdoor zal de verschuiving groter zijn dan die van de originele methode. Dat het karakter verschilt kan niet garanderen dat het overkomt met T[j] (maar als het hetzelfde is dan is het zowieso fout dus), daarom moeten we eventueel nog een kleinere prefix nemen.
\item aangezien deze vereiste enkel afhankelijk is van P kunnen we ze op voorhand volledig bepalen, dit noemen we p2() of p'().
\end{itemize}

\item \textbf{Uiteindelijk gebruiken we nog een foutfunctie f(i)}
\begin{itemize}
\item (i) = p'(i-1) + 1
\item Deze functie geeft voor elke patroonpositie i groter dan een meteen de patroon positie waarmee T[j] moet vergeleken worden.
\item als we ook f(m+1) op die manier defini\"eren dan geeft die de nieuwe te testen patroon positie na het vinden van P. (Dus als we P vinden hoeveel moeten we dan schuiven om een volgende te vinden (overlap)).
\item Als i == 1 moet P een positie opgeschoven worden en wordt P[1] vergeleken met T[j+1] daarom moet f(1) = 1 zijn en p'(0) = 0 ; p'(1)  = 0
\end{itemize}
\end{enumerate}

het aantal karakter vergelijkingen van dit algoritme is $\theta(n)$. Want na elke verschuiving van P wordt hoogstens een karakter van T getest dat vroeger reeds getest werd. (Als het opnieuw niet overeenkomt wordt er doorgeschoven). Het totaal aantal karaktervergelijking is dus hoogstens gelijk aan de lengte T, plus het aantal verschuivingen. Elke verschuiving gebeurd over minstens 1 positie, zodat het aantal verschuivingen O(n) is. Dit levert dus idd $\theta(n)$.
\npar
Aangezien de voorbereiding van de prefix functie, de nieuwe prefixfunctie en de foutfunctie $\theta(m)$ is, wordt de totale performantie $\theta(m+n)$